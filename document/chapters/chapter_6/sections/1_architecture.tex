\section{Architecture}
This section describes the software architecture proposed by this project in order to realize the Transparent scheduling model over heterogeneous devices and, consequently, satisfy the requirements and use cases previously described.

\textit{Figure \ref{fig:architecture_complete}} provides a \textbf{complete view of the Architecture}; being a complex project based on the interaction between multiple distributed entities, the schema will be divided in \textbf{three areas} (easier to understand) that will be discussed in the following sections:
\begin{itemize}
    \item \textbf{Cloud Services area} (\textit{section \ref{cloud_services_area}})
    \item \textbf{Contributor area} (\textit{section \ref{contributor_area}})
    \item \textbf{Customer area} (\textit{section \ref{customer_area}})
\end{itemize}
\begin{figure}[!ht]
    \centering
    \includegraphics[width=\linewidth]{document/chapters/chapter_6/images/architecture_complete.jpg}
    \caption{Complete view of the Architecture}
    \label{fig:architecture_complete}
\end{figure}

\subsection{Cloud Services Area}\label{cloud_services_area}
The \textbf{Cloud Services} follow a \textbf{hexagonal architecture} composed by a multitude of \textbf{microservices} (\textit{Figure \ref{fig:architecture_cloud_services}}). Each Microservice is \textbf{accessed through communication interfaces} (whether \textbf{Rest APIs and/or Web Sockets}, depending on the particular microservice needs) \textbf{and belong to one of the following two layers}:
\begin{itemize}
    \item \textbf{Business logic}\\
    Microservices that \textbf{expose core business logic for Grid functionalities realization and data managing}. Entities that  reside here are \textbf{protected}, meaning that they are isolated from the outside and \textbf{their functionalities can only be accessed through the entities placed in the Adapters layer}.
    \item \textbf{Adapters}\\
    Microservices that \textbf{expose functionalities accessed by the entities residing in the Contributor and Customer area}; such functionalities are \textbf{realized combining the services} offered by entities residing \textbf{in the Business logic layer}.
\end{itemize}
\begin{figure}[!ht]
    \centering
    \includegraphics[scale=0.35]{document/chapters/chapter_6/images/architecture_cloud_services.jpg}
    \caption{Architecture: Cloud Services}
    \label{fig:architecture_cloud_services}
\end{figure}

\subsubsection{Business Logic}
\begin{itemize}
    \item \textbf{Grid Master Service}\\
    The \textbf{main coordinator in the Grid} system. It \textbf{dynamically creates/removes Broker Service instances} in order to sustain and balance the traffic generated by Nodes and Invoking Endpoints connected to the current instances of Broker Service; such instances needs to be contacted by Nodes but, being dynamically instantiated, they do not possess a static address. As a consequence of that, \textbf{the Grid Master Service} (that knows such addresses, being the creator of the instances) \textbf{is connected to the Broker Discovery System} (which will provide a Broker Service instance address to a connecting Node).

    \textit{Figure \ref{fig:master_grid_load_balancing}} shows a \textbf{high level view of the connection between Grid Master, Brokers and Nodes} while also providing an \textbf{example of load balancing}. When the new Node [N11] wants to connect to the Grid in order to Contribute, given that no Broker instance is able to handle the Node connection, the Grid Master instantiates [B2] to which [N11] will connect and part of the load handled by [B1] (just [N9] in this example) will be redirected to.
    \begin{figure}[!ht]
        \centering
        \includegraphics[width=\linewidth]{document/chapters/chapter_6/images/master_grid_load_balancing.jpg}
        \caption{Grid Master Service load balancing}
        \label{fig:master_grid_load_balancing}
    \end{figure}

    Lastly, the Grid Master Service is \textbf{also connected to the Grid Services Gateway Service}; through this last Cloud Service, the Invoking Endpoints request the execution of Grid Services. Thus, the Grid Master (collaborating with the Broker Service instances) will \textbf{provide the Resources needed to execute the requested Grid Service}.

    Concluding, this Cloud Service's importance is vital to the functioning and scalability of the Grid, requiring to expose \textbf{communication interfaces for the discovery of Brokers, Resources obtainment and Grid coordination}.

    \item \textbf{Customer Data Service}\\
    REST server that provides \textbf{APIs used to read and write data used to uniquely identify a Customer inside the system}. It \textbf{does not contain data about payments or logs} about Grid events that involve the Customer since those are handled by the Accounting Service and the Log Service respectively.\\
    Customers are, numerically speaking, considerably less compared to Contributors; this results in \textbf{less frequent invocations} of this Cloud Service's APIs and a \textbf{far smaller volume of data to persist}. Regarding the CAP theorem, it is then important to \textbf{focus on a database technology that can grant Consistency and Partition Tolerance} sacrificing Availability (e.g. MongoDB, BigTable, etc...).

    \item \textbf{Contributor Data Service}\\
    REST server that exposes \textbf{APIs used to read and write data used to uniquely identify a Contributor and its devices inside the system}. The same rules used in the Customer Data Service, regarding the handling of logs and payments data, also hold here; when it comes to the CAP theorem application, on the contrary, \textbf{this Cloud Service requires AP database technologies} (e.g. DynamoDB, Cassandra, etc...).

    \item \textbf{Accounting Service}\\
    REST server exposing APIs to \textbf{perform and record the history of monetary transactions, involving both Customers and Contributors} (i.e. Fees payments and Rewards Redemptions) inside the Grid; \textbf{Consistency and Partition Tolerance} here are key requirements.

    \item \textbf{Log Service}\\
    REST server providing APIs used to \textbf{read and write unmodifiable logs about Contributions and Grid Services Invocations}; this Cloud Service is particularly important to both monitor what is happening inside the Grid and also correctly identify which Node has performed a Contribution and how much of said Contribution it has done. \textbf{Access speed is the most relevant factor here, making it acceptable to have eventual consistency but not delays}; then, \textbf{AP database technologies are required here}. In particular, said AP database technology should use an RDF model (also known as Triplestore) which is particularly suited for log data.
\end{itemize}

\subsubsection{Adapters}
\begin{itemize}
    \item \textbf{Broker Service}\\
    Cloud Service that \textbf{acts as middleware between the Grid Master and the Nodes} (\textit{figure \ref{fig:master_grid_load_balancing}}). There are \textbf{as many instances as needed to sustain the load of the connections to the Nodes}; instances are \textbf{created and removed by the Grid Master} taking in account the \textbf{geographical location} of said Nodes in order to reduce latency for the Broker-Node connection.
    The Broker \textbf{executes the coordination commands given by the Grid Master} while \textbf{also managing the Nodes connected} through its communication channels exposed by its Web Socket.
    
    Let us take, for example, a Grid Service Invocation: the Grid Master contacts a Broker Service instance that is geographically convenient in relationship to the location of the Invoking Endpoint; the Grid Master will delegate to the selected Broker Service instance the responsibility of gathering adequate Resources for the execution of the particular Grid Service requested. The Broker will then spread the request of said Resources to its connected Nodes and gather the responses of the ones that are adequate and available. The Broker will group the info needed to contact such nodes and forward it to the Grid Master that will then be responsible to forward in turn to the requestor.

    \item \textbf{Broker Discovery Service}\\
    This REST server has just one simple responsibility: \textbf{it provides to a Node the address of a Broker Service in order to make possible a connection between them}. This discovery mechanism is necessary since, as already stated, the Broker Service instances are dynamically created, and thus they do not possess a static address; on the contrary \textbf{the Broker Discovery Service will necessarily need a static address known by the Nodes}. The traffic directed to this Cloud Service and its computational load tend to be minimal and requires only one instance but, as time goes on and the contributing user base increases, new static instances can be added easily.

    \item \textbf{Grid Services Gateway Service}\\
    In order for Invoking Endpoints to access Resources, they need to interact with this REST server; \textbf{it exposes APIs for a standardized and parameterized access to Resources through the Grid Service abstraction}, meaning that a Customer expresses its request in terms of what Grid Service it wants to execute, not in terms of single Resources.
    
    This Cloud Service is \textbf{connected via Web Socket to the Grid Master Service in order to gather the necessary Resources} but, before that, the Grid Services Gateway Service \textbf{needs to contact the Accounting Service} in order to execute the Fee payment. Lastly, the Cloud Service is \textbf{also connected to the Log Service} in order to register the Grid Service invocation and the consequent usage of Resources happened during the computation.

    Similarly to the Broker Discovery Service, the number of static instances easily can vary in the project's lifecycle. 

    \item \textbf{Authentication Service}\\
    Before being able to communicate with any other Cloud Service belonging to the Adapters layer, \textbf{any entity needs to authenticate to the Grid through this Cloud Service}. Given that \textbf{the two actors that require authentication are the Customer and the Contributor}, the Authentication Service utilizes both the \textbf{Customer Data Service and the Contributor Data Service} in its functioning. As a consequence of the authentication, the entity that wants to interact with the Grid will receive a \textbf{token that uniquely identifies it inside the Grid system}.

    \item \textbf{Billing Service}\\
    Cloud Service exposing APIs used \textbf{to make monetary transactions for Rewards Redemptions and access monetary balances}. It acts as an intermediary, protecting the actual payment process effectuated by the Accounting Service.

    \item \textbf{Historian Service}\\
    The Historian Service exposes APIs that allow the \textbf{read-only access to event already happened in the Grid System as well as the registration of new events} like monetary transactions, Contribution, Grid Services Invocations, etc...

\end{itemize}
\vspace{20mm}

\subsection{Contributor area}\label{contributor_area}
The Contributor area, as shown in \textit{figure \ref{fig:architecture_contributor}}, comprehends three entities:
\begin{itemize}
    \item \textbf{Node}
    \item \textbf{Contributing Endpoint}
    \item \textbf{Contributor Dashboard}
\end{itemize}
The relevant Cloud Services are shown in order to explain the interactions that Node and the Contributor Dashboard have with them; in particular, the Grid Master Service is shown to emphatize the Grid Master - Broker - Node connection seen in \textit{figure \ref{fig:master_grid_load_balancing}}.

Moreover, the Invoking Endpoint (which belongs to the Customer area) and the additional Node instance are included to show the connections that a Node can have with other entities that do not belong to the Cloud Services.

\vspace{5mm}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=\linewidth]{document/chapters/chapter_6/images/architecture_contributor.jpg}
    \caption{Architecture: Contributor area}
    \label{fig:architecture_contributor}
\end{figure}

\subsubsection{Node}
This is the primary entity when it comes to contribution.
Continuing the definition provided in the Ubiquitous Language (\textit{section \ref{ubiquitous_language}}), this software abstraction is identifiable as a set of core Contribution functionalities and logic which needs to be integrated (through the offered SDK) to an actual software application (Contributing Endpoint) capable of interacting with the specific resources of the device that is running it; thus, a Node exists in order to get a fast integration with as many devices as possible to maximize the compatibility for Contribution, removing the need to reimplement everything for every new Contributing Endpoint.

The model of this solution aims to grant the access to Grid Services also to low-spec devices; thus, it is important to delegate as much work as possible to the Nodes. In order to complete a Grid Service, the Node can Contribute in one of the following ways (depending on the particular Service):
\begin{itemize}
\item \textbf{Direct communication with the Invoking Endpoint}\\
A Node is connected, through a Web Socket, directly to the Invoking Endpoint. Let us take, for example, a hypothetical Grid Service that consists of delegating a computation to a single Node (i.e. non-distributed computation); the Node (Slave) and the Invoking Endpoint (Master) will exchange messages in order for the Invoking Endpoint to provide to the Node the necessary data and coordinating the Node that will actually perform the resource-demanding computation. In this communication mode a Node acts only passively.
Another example, relevant for this thesis work, is the connection between an Invoking Endpoint and a Node acting as MapReduce Master (\textit{figure TODO}).
\item \textbf{Communication with another Node}\\
A Node is connected, through a Web Socket, to another Node; there are indeed circumstances that, for the completion of a particular Grid Service, require direct communication among Nodes. While in the other communication type the Node had only a passive role, here one of the two nodes needs to act as Master while the other(s) as Slave(s). 
Continuing the MapReduce example, a Node acting as MapReduce Master is connected to multiple nodes acting either as Map Workers or Reduce Workers (\textit{figure TODO}).
\end{itemize}

Once again, a Grid Service is performed by Nodes that Contribute, communicating with each other, performing Tasks in order to reach the end goal; the Task concept is vital here since, while every Node will have the same communication interfaces, different Contributing Endpoints will implement Tasks based on the device's capabilities. That means that, when concretized through the Contributing Endpoint, not all Nodes will be able to execute every possible Task, but only the ones that are compatible with the Resources possessed (e.g.: an iPhone running iOS will not be able to perform a MapReduce computation that uses Map and/or Reduce functions written in Java).

With the goal of reducing complexity, compatibility wise (\textit{sections \ref{standardized_mobile_market} and \ref{compatibility_issues}}), the number of different Node incarnations (that differ for the technologies used to develop it) should be very low; ideally, just one implementation, integrable with a great number of Contributing Endpoints, should exist to maximize the integration speed benefits.

\subsubsection{Contributing Endpoint}
A Contributing Endpoint is a concrete application that will be used by the Contributor. Through the Node's SDK, it implements device-specific access to Resources and, consequently, the Tasks that this particular Contributing Endpoint implementation will be able to support.

In particular, it is important that a concrete implementation incorporates the security measures available for that particular execution environment (collaborating with the general security mechanisms of the Grid).
There can be different Contributing Endpoint implementations, with every new one expanding the number of devices able to Contribute.

\subsubsection{Contributor Dashboard}
A Dashboard, used by the Contributor, to perform operations linked to its Contribution (Rewards Redemption, checking past Contributions, etc...); it should serve as a unified way to access to information regarding all its different Contributing Endpoints.

This is certainly an easier (compared to Node and Contributing Endpoint) and more traditional client application, requiring only to contact Cloud Services in order to represent through a GUI the information obtained, as well as performing some operations specified in the Contributor's use case diagram (\textit{figure \ref{fig:use_cases_contributor}}). 

\subsection{Customer area}\label{customer_area}
\textit{Figure \ref{fig:architecture_customer}} shows the three entities belonging to this area:
\begin{itemize}
    \item \textbf{Invoking Endpoint}
    \item \textbf{Customer Custom Application}
    \item \textbf{Customer Dashboard}
\end{itemize}
As for the Contributor area, the relevant Cloud Services and the Node instance are shown to emphasize how these entities collaborate with each other.

It is also important to highlight the fact that both the Customer Custom Application User and the Customer itself are present in the figure since the actor using the Customer Custom Application do not necessarily coincide with the Customer; who the Customer Custom Application User actually is highly depends on the application itself.
\vspace{8mm}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=\linewidth]{document/chapters/chapter_6/images/architecture_customer.jpg}
    \caption{Architecture: Customer area}
    \label{fig:architecture_customer}
\end{figure}

\subsubsection{Invoking Endpoint}
The Invoking Endpoint is the main software entity used by the Customer to perform Grid Services Invocations. It is a library, developed by the Grid Owner, that can be integrated as a dependency and utilized into any software solution through the use of the exposed SDK; in particular, an application utilizing an Invoking Endpoint is identified as Customer Custom Application.

Many Invoking Endpoint implementations can exist, depending on the target execution environment and which Grid Services that specific Invoking Endpoint wants to grant access to (a Customer may want to use only a certain type of Grid Service); the requirement for any Invoking Endpoint is, in order to connect to a Node in a Grid Service Invocation, to conform to the communication interfaces belonging to the Grid Services which is interested to use.

An Invoking Endpoint (after being authenticated through the Authentication Service) contacts the Grid Services Gateway Service in order to request a Service Invocation and, as a consequence of that, creates a connection to the provided Node(s). In order to grant the possibility of Grid Services invocation from low-spec devices, the Invoking Endpoint needs just to perform a lightweight coordination of the Resources obtained while the computationally demanding work is executed by the Nodes connected; in cases where the coordination is too complex and demanding to realistically be executed from any device, the Invoking Endpoint just connects to a Node which actually performs the coordination: An example of such occurrence is the MapReduce Service where the MapReduce Master is the one performing the coordination of Map Workers and Reduce Workers while the Invoking Endpoint is only connected to the MapReduce Master.

\subsubsection{Customer Custom Application}
An application utilizing the Invoking Endpoint. It is developed by the Customer and utilizes Grid Services (offered by the Invoking Endpoint) in order to build complex behaviors that are dependent on the application's domain.

Grid Services Invocation happens through the invocation of the functions exposed by the Invoking Endpoint's SDK, masking the underlying complexity requiring for the Customer to specify some parameters (like, eventually, the quantity of Resources that it wants to use).

\subsubsection{Customer Dashboard}
Similarly to the Contributor's one, this Dashboard is a centralized mean of accessing everything connected to the Contributor's account (past Grid Service Invocations, payment methods, etc...) as well as perform actions specified by the Customer Use cases (\textit{figure \ref{fig:use_cases_customer}}).
